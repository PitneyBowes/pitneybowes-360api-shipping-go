/*
Shipping APIs

### Introduction  The Shipping APIs include a variety of operations that allow users to manage and track their shipping requests.   Some of the key API operations available in the Shipping API includes: ### Shipment API  | Operation      | Description | | ----------- | ----------- |  | Get Carriers    | This operation fetches all onboarded carriers. Typically, user will use this service to get list of onboarded carriers and supported properties for those carriers.  |  | Get Countries | This operation fetches list of supported destination countries for a provided carrier and origin country.  |  | Get Services | This operation fetches a list of supported services for a carrier with respect to specific origin and destination country. |  | Get ParcelTypes| This operation fetches ParcelTypes based on carrier, origin and destination country. |  | Get Special Services| This operation fetches Special Services for a given carrier, service, origin and destination country. |  | Get Carrier Accounts| This operation retrieves onboarded Carriers with their Carrier Account Ids which uniquely identify multiple accounts of same carrier.  |  | Rate Shop and Get Single Rate| This API contains 2 operations, rate shop and single rate. Rate shop will fetch rates for all carrier services based on the given addresses (From and To), weight, and dimension for given parcelType. Single rate will get rate for specific service and special service (if requested) based on the given addresses (From and To), weight, and dimension, parcelType and serviceId with or without specialServices. Single rate will be used mainly to a rate a shipment before creating shipment.  |  | Create Shipment| This operation creates a new Shipment or Shipment Label. This is for both Domestic and International. | | Get All Shipments| This operation fetches all created Shipments. |  | Get Shipment by Id| Retrieves single shipment using Shipment Id. |  | Reprint Shipment| This operation reprints Shipment by the shipmentId. It retrieves an existing shipping label to reprint. The API sends the shipmentId returned by the original Created Shipment request. Use this only if the shipping label in the Create Shipment response was spoilt or lost. |  | Cancel Shipment| This operation cancels previously created shipment. |  

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package shipping

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ShipmentByRateShopAPIService ShipmentByRateShopAPI service
type ShipmentByRateShopAPIService service

type ApiCancelShipmentByIdV2Request struct {
	ctx context.Context
	ApiService *ShipmentByRateShopAPIService
	shipmentCancelV2 *ShipmentCancelV2
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

func (r ApiCancelShipmentByIdV2Request) ShipmentCancelV2(shipmentCancelV2 ShipmentCancelV2) ApiCancelShipmentByIdV2Request {
	r.shipmentCancelV2 = &shipmentCancelV2
	return r
}

// The Developer Partner ID is assigned by PB to uniquely identify a Developer&#39;s strategic business partners. If the developer is the sole business partner, this field isn&#39;t required.
func (r ApiCancelShipmentByIdV2Request) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiCancelShipmentByIdV2Request {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer&#39;s and Partner&#39;s parsed locations, to which all transactions will be billed. &lt;br /&gt; Partner&#39;s location will be used for billing if it is configured, however, in case Partner&#39;s location is not given, then the Developer&#39;s location will be taken. Developer&#39;s location will be the default value. &lt;br /&gt; Additionally, Developers and Partners can use carriers belong to this location only.
func (r ApiCancelShipmentByIdV2Request) XPBLocationId(xPBLocationId string) ApiCancelShipmentByIdV2Request {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique Transaction ID provided by the partner which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiCancelShipmentByIdV2Request) XPBTransactionId(xPBTransactionId string) ApiCancelShipmentByIdV2Request {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiCancelShipmentByIdV2Request) Execute() (*CancelShipmentV2, *http.Response, error) {
	return r.ApiService.CancelShipmentByIdV2Execute(r)
}

/*
CancelShipmentByIdV2 Cancel Shipment

The operation cancel/void shipment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelShipmentByIdV2Request
*/
func (a *ShipmentByRateShopAPIService) CancelShipmentByIdV2(ctx context.Context) ApiCancelShipmentByIdV2Request {
	return ApiCancelShipmentByIdV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CancelShipmentV2
func (a *ShipmentByRateShopAPIService) CancelShipmentByIdV2Execute(r ApiCancelShipmentByIdV2Request) (*CancelShipmentV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelShipmentV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentByRateShopAPIService.CancelShipmentByIdV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/shipments/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shipmentCancelV2 == nil {
		return localVarReturnValue, nil, reportError("shipmentCancelV2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	// body params
	localVarPostBody = r.shipmentCancelV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShipmentV2Request struct {
	ctx context.Context
	ApiService *ShipmentByRateShopAPIService
	createShipmentV2Request *CreateShipmentV2Request
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

func (r ApiCreateShipmentV2Request) CreateShipmentV2Request(createShipmentV2Request CreateShipmentV2Request) ApiCreateShipmentV2Request {
	r.createShipmentV2Request = &createShipmentV2Request
	return r
}

// The Developer Partner ID is assigned by PB to uniquely identify a Developer&#39;s strategic business partners. If the developer is the sole business partner, this field isn&#39;t required.
func (r ApiCreateShipmentV2Request) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiCreateShipmentV2Request {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer&#39;s and Partner&#39;s parsed locations, to which all transactions will be billed. &lt;br /&gt; Partner&#39;s location will be used for billing if it is configured, however, in case Partner&#39;s location is not given, then the Developer&#39;s location will be taken. Developer&#39;s location will be the default value. &lt;br /&gt; Additionally, Developers and Partners can use carriers belong to this location only.
func (r ApiCreateShipmentV2Request) XPBLocationId(xPBLocationId string) ApiCreateShipmentV2Request {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique Transaction ID provided by the partner, which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiCreateShipmentV2Request) XPBTransactionId(xPBTransactionId string) ApiCreateShipmentV2Request {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiCreateShipmentV2Request) Execute() (*DomesticShipmentResponseV2, *http.Response, error) {
	return r.ApiService.CreateShipmentV2Execute(r)
}

/*
CreateShipmentV2 Create Shipment

The operation creates a new Shipment or generate a Shipment Label.
- To create a domestic shipment, the operation requires
  - Domestic addresses 'To' and 'From' locations respectively within the same country
  - carrier services, and
  - associated special services.
- While for the International shipment, the operation requires
  - International address(es) for delivery, that is 'To' address must be the international country location(s) and not the same country mentioned in 'From' address
  - supported international carrier services
  - associated special service(s), and 
  - customs information.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateShipmentV2Request
*/
func (a *ShipmentByRateShopAPIService) CreateShipmentV2(ctx context.Context) ApiCreateShipmentV2Request {
	return ApiCreateShipmentV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DomesticShipmentResponseV2
func (a *ShipmentByRateShopAPIService) CreateShipmentV2Execute(r ApiCreateShipmentV2Request) (*DomesticShipmentResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DomesticShipmentResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentByRateShopAPIService.CreateShipmentV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/shipments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createShipmentV2Request == nil {
		return localVarReturnValue, nil, reportError("createShipmentV2Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	// body params
	localVarPostBody = r.createShipmentV2Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReprintShipmentByIdV2Request struct {
	ctx context.Context
	ApiService *ShipmentByRateShopAPIService
	shipmentReprintV2 *ShipmentReprintV2
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

func (r ApiReprintShipmentByIdV2Request) ShipmentReprintV2(shipmentReprintV2 ShipmentReprintV2) ApiReprintShipmentByIdV2Request {
	r.shipmentReprintV2 = &shipmentReprintV2
	return r
}

// The Developer Partner ID is assigned by PB to uniquely identify a Developer&#39;s strategic business partners. If the developer is the sole business partner, this field isn&#39;t required.
func (r ApiReprintShipmentByIdV2Request) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiReprintShipmentByIdV2Request {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer&#39;s and Partner&#39;s parsed locations, to which all transactions will be billed. &lt;br /&gt; Partner&#39;s location will be used for billing if it is configured, however, in case Partner&#39;s location is not given, then the Developer&#39;s location will be taken. Developer&#39;s location will be the default value. &lt;br /&gt; Additionally, Developers and Partners can use carriers belong to this location only.
func (r ApiReprintShipmentByIdV2Request) XPBLocationId(xPBLocationId string) ApiReprintShipmentByIdV2Request {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique transaction Id provided by the partner which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiReprintShipmentByIdV2Request) XPBTransactionId(xPBTransactionId string) ApiReprintShipmentByIdV2Request {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiReprintShipmentByIdV2Request) Execute() (*ReprintShipmentV2, *http.Response, error) {
	return r.ApiService.ReprintShipmentByIdV2Execute(r)
}

/*
ReprintShipmentByIdV2 Reprint Shipment

The operation reprints Shipment by the shipmentId. It retrieves an existing shipping label to reprint. The API sends the shipmentID returned by the original created shipment request. Use this only if the shipping label in the Create Shipment response is missing or lost.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReprintShipmentByIdV2Request
*/
func (a *ShipmentByRateShopAPIService) ReprintShipmentByIdV2(ctx context.Context) ApiReprintShipmentByIdV2Request {
	return ApiReprintShipmentByIdV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReprintShipmentV2
func (a *ShipmentByRateShopAPIService) ReprintShipmentByIdV2Execute(r ApiReprintShipmentByIdV2Request) (*ReprintShipmentV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReprintShipmentV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentByRateShopAPIService.ReprintShipmentByIdV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/shipments/reprint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shipmentReprintV2 == nil {
		return localVarReturnValue, nil, reportError("shipmentReprintV2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	// body params
	localVarPostBody = r.shipmentReprintV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
