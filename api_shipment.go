/*
Shipping APIs

### Introduction  The Shipping APIs include a variety of operations that allow users to manage and track their shipping requests.   Some of the key API operations available in the Shipping API includes: ### Shipment API  | Operation      | Description | | ----------- | ----------- |  | Get Carriers    | This operation fetches all onboarded carriers. Typically, user will use this service to get list of onboarded carriers and supported properties for those carriers.  |  | Get Countries | This operation fetches list of supported destination countries for a provided carrier and origin country.  |  | Get Services | This operation fetches a list of supported services for a carrier with respect to specific origin and destination country. |  | Get ParcelTypes| This operation fetches ParcelTypes based on carrier, origin and destination country. |  | Get Special Services| This operation fetches Special Services for a given carrier, service, origin and destination country. |  | Get Carrier Accounts| This operation retrieves onboarded Carriers with their Carrier Account Ids which uniquely identify multiple accounts of same carrier.  |  | Rate Shop and Get Single Rate| This API contains 2 operations, rate shop and single rate. Rate shop will fetch rates for all carrier services based on the given addresses (From and To), weight, and dimension for given parcelType. Single rate will get rate for specific service and special service (if requested) based on the given addresses (From and To), weight, and dimension, parcelType and serviceId with or without specialServices. Single rate will be used mainly to a rate a shipment before creating shipment.  |  | Create Shipment| This operation creates a new Shipment or Shipment Label. This is for both Domestic and International. | | Get All Shipments| This operation fetches all created Shipments. |  | Get Shipment by Id| Retrieves single shipment using Shipment Id. |  | Reprint Shipment| This operation reprints Shipment by the shipmentId. It retrieves an existing shipping label to reprint. The API sends the shipmentId returned by the original Created Shipment request. Use this only if the shipping label in the Create Shipment response was spoilt or lost. |  | Cancel Shipment| This operation cancels previously created shipment. |  

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package shipping

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ShipmentAPIService ShipmentAPI service
type ShipmentAPIService service

type ApiCancelShipmentByIdRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	xPBDeveloperPartnerID *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCancelShipmentByIdRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiCancelShipmentByIdRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiCancelShipmentByIdRequest) Execute() (*CancelShipment, *http.Response, error) {
	return r.ApiService.CancelShipmentByIdExecute(r)
}

/*
CancelShipmentById Cancel Shipment

This operation cancel/void shipment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId This indicates the shipmentId, a unique identifier assigned for the Shipment.
 @return ApiCancelShipmentByIdRequest
*/
func (a *ShipmentAPIService) CancelShipmentById(ctx context.Context, shipmentId string) ApiCancelShipmentByIdRequest {
	return ApiCancelShipmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return CancelShipment
func (a *ShipmentAPIService) CancelShipmentByIdExecute(r ApiCancelShipmentByIdRequest) (*CancelShipment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelShipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CancelShipmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelStampsERRRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	cancelStampsRequestERR *CancelStampsRequestERR
	xPBDeveloperPartnerID *string
}

func (r ApiCancelStampsERRRequest) CancelStampsRequestERR(cancelStampsRequestERR CancelStampsRequestERR) ApiCancelStampsERRRequest {
	r.cancelStampsRequestERR = &cancelStampsRequestERR
	return r
}

// The Developer Partner ID is assigned by PB to uniquely identify a Developer&#39;s strategic business partners. If the developer is the sole business partner, this field is not required.
func (r ApiCancelStampsERRRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiCancelStampsERRRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiCancelStampsERRRequest) Execute() (*CancelStampsResponseERR, *http.Response, error) {
	return r.ApiService.CancelStampsERRExecute(r)
}

/*
CancelStampsERR Cancel Stamps ERR

This operation cancels (voids) stamps generated for ERR (Electronic Return Receipt). 
- User needs to provide *Stamp IDs* to cancel those specific ERR stamps. 
- User can download the *Refund Form* having details of generated Postage. 
- At once, maximum 1000 stamps can be requested for cancelation.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelStampsERRRequest
*/
func (a *ShipmentAPIService) CancelStampsERR(ctx context.Context) ApiCancelStampsERRRequest {
	return ApiCancelStampsERRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CancelStampsResponseERR
func (a *ShipmentAPIService) CancelStampsERRExecute(r ApiCancelStampsERRRequest) (*CancelStampsResponseERR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelStampsResponseERR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CancelStampsERR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/err/stamps/void"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelStampsRequestERR == nil {
		return localVarReturnValue, nil, reportError("cancelStampsRequestERR is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.cancelStampsRequestERR
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReturnLabelRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	returnLabel *ReturnLabel
	xPBDeveloperPartnerID *string
}

func (r ApiCreateReturnLabelRequest) ReturnLabel(returnLabel ReturnLabel) ApiCreateReturnLabelRequest {
	r.returnLabel = &returnLabel
	return r
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCreateReturnLabelRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiCreateReturnLabelRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiCreateReturnLabelRequest) Execute() (*ReturnLabelResponse, *http.Response, error) {
	return r.ApiService.CreateReturnLabelExecute(r)
}

/*
CreateReturnLabel Create Return label shipment

This operation creates a return label based on a previous shipment. <br> The return label can be created in two ways:  <br> 1. User need not to provide any details of package, address and service. The API would take all details from the shipmentId mentioned in the path parameter and would swap the address and create return label. However for UPS `specialServices` object is required as carrier mandates to provide package description with PRL special service. <br> 2. User can customize the request by passing `fromAddress`, `toAddress`, `parcelType`, `serviceId` in the request itself. <br> Please Note that for UPS it is required to pass `specialServices` object with `PRL` service id and  input parameters with name as `RETURN_PKG_DESCRIPTION`. <br> For FedEx `specialServices` object is not required and PRL is added by default while creating return.  If user wishes to provide RMA number, it can be passed in `specialServices` object in the request body. <br> Please Note If user provides any information in this request it overrides the information in onward shipment which was created <br> For example if user provides toAddress in the request the return label will get created with recipient as mentioned in toAddress and  if user provides fromAddress in the request, the return label will be created with sender as mentioned in fromAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId It specifies the shipmentId of onward shipment against which return label has to be created.
 @return ApiCreateReturnLabelRequest
*/
func (a *ShipmentAPIService) CreateReturnLabel(ctx context.Context, shipmentId string) ApiCreateReturnLabelRequest {
	return ApiCreateReturnLabelRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return ReturnLabelResponse
func (a *ShipmentAPIService) CreateReturnLabelExecute(r ApiCreateReturnLabelRequest) (*ReturnLabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReturnLabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CreateReturnLabel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}/return"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnLabel == nil {
		return localVarReturnValue, nil, reportError("returnLabel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.returnLabel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShipmentRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	createShipmentRequest *CreateShipmentRequest
	xPBDeveloperPartnerID *string
}

func (r ApiCreateShipmentRequest) CreateShipmentRequest(createShipmentRequest CreateShipmentRequest) ApiCreateShipmentRequest {
	r.createShipmentRequest = &createShipmentRequest
	return r
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCreateShipmentRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiCreateShipmentRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiCreateShipmentRequest) Execute() (*CreateShipment200Response, *http.Response, error) {
	return r.ApiService.CreateShipmentExecute(r)
}

/*
CreateShipment Create Shipment

This operation creates a new Shipment or Shipment Label. This is for both Domestic and International.<br> For domestic, Create a shipment requires domestic addresses (within same country)- ToAddress and FromAddress, and  carrier service and special service.<br> While for International, Create a shipment requires international delivery, that is ToAddress must be the different country (and not the same country mentioned in From Address), selected services, special services, and customs information. <br> <br> Note- To create Return shipment using this API- If PRL (return special service) is used, user need to provide sender address (from where return shipment is to be created) in `fromAddress` object and recipient address (to where return is to be created) in `toAddress` object. System will not swap the address for return in this API. If you want to create return for the already created shipment, you may use `Create Return Label Shipment` API. <br> <br> Note: Currently Shipment created from below API gets assigned to the Default location of the subscription.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateShipmentRequest
*/
func (a *ShipmentAPIService) CreateShipment(ctx context.Context) ApiCreateShipmentRequest {
	return ApiCreateShipmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateShipment200Response
func (a *ShipmentAPIService) CreateShipmentExecute(r ApiCreateShipmentRequest) (*CreateShipment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateShipment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CreateShipment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createShipmentRequest == nil {
		return localVarReturnValue, nil, reportError("createShipmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.createShipmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadBpodFilesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
	startDate *string
	endDate *string
	body *BPODDownloadRequest
}

// The Developer Partner ID is assigned by PB to uniquely identify a Developer&#39;s strategic business partners. If the developer is the sole business partner, this field is not required.
func (r ApiDownloadBpodFilesRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiDownloadBpodFilesRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// The BPOD files to be downloaded from which Date is the startDate in the Date Range filter. This field is not required if the Shipment IDs provided in the request body.
func (r ApiDownloadBpodFilesRequest) StartDate(startDate string) ApiDownloadBpodFilesRequest {
	r.startDate = &startDate
	return r
}

// The BPOD files to be downloaded till which Date is the endDate in the Date Range filter. This field is not required if the Shipment IDs provided in the request body.
func (r ApiDownloadBpodFilesRequest) EndDate(endDate string) ApiDownloadBpodFilesRequest {
	r.endDate = &endDate
	return r
}

// This is the request body to download BPOD files. Request body supports max of 1000 ShipmentIDs in a request.
func (r ApiDownloadBpodFilesRequest) Body(body BPODDownloadRequest) ApiDownloadBpodFilesRequest {
	r.body = &body
	return r
}

func (r ApiDownloadBpodFilesRequest) Execute() (*BPODDownloadResponse, *http.Response, error) {
	return r.ApiService.DownloadBpodFilesExecute(r)
}

/*
DownloadBpodFiles Download BPOD Files

This API operation is used to download bulk of ERR (*Electronic Return Receipt*) - POD (*Proof of Delivery*) files, which are specific to USPS carrier. <br />
  User can download BPOD (*Bulk Proof of Delivery*) files either using *Shipment IDs* or *Date Range*. 
  If user wants to check records based on dates and download BPOD files accordingly, then *Start Date* and *End Date* need to be passed in the request body as filter. Else *Shipment IDs* will be used as default value when user does not provide *DateRange* filter. <br />
  User is restricted to download 1000 BPOD files as max limit.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDownloadBpodFilesRequest
*/
func (a *ShipmentAPIService) DownloadBpodFiles(ctx context.Context) ApiDownloadBpodFilesRequest {
	return ApiDownloadBpodFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BPODDownloadResponse
func (a *ShipmentAPIService) DownloadBpodFilesExecute(r ApiDownloadBpodFilesRequest) (*BPODDownloadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BPODDownloadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.DownloadBpodFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/err/shipments/bpod"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllShipmentsRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
	startDate *string
	endDate *string
	page *string
	size *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetAllShipmentsRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetAllShipmentsRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// While searching shipments, user set a date range to get all created shipments. This indicatesthe start date of the set date range under shipment search criteria. The date format must be: YYYY-MM-DD.
func (r ApiGetAllShipmentsRequest) StartDate(startDate string) ApiGetAllShipmentsRequest {
	r.startDate = &startDate
	return r
}

// While searching shipments, user set a date range to get all created shipments. This indicatesthe end date of the set date range under shipment search criteria. The date format must be: YYYY-MM-DD.
func (r ApiGetAllShipmentsRequest) EndDate(endDate string) ApiGetAllShipmentsRequest {
	r.endDate = &endDate
	return r
}

// This indicates the page of the Shipments search result list.
func (r ApiGetAllShipmentsRequest) Page(page string) ApiGetAllShipmentsRequest {
	r.page = &page
	return r
}

// This indicates the size/count of the searched result list.
func (r ApiGetAllShipmentsRequest) Size(size string) ApiGetAllShipmentsRequest {
	r.size = &size
	return r
}

func (r ApiGetAllShipmentsRequest) Execute() (*GetAllShipments, *http.Response, error) {
	return r.ApiService.GetAllShipmentsExecute(r)
}

/*
GetAllShipments Get All Shipments

This operation fetches all created Shipments. If query parameters are not provided, it will default endDate as current date, page as 1 and size as 10.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllShipmentsRequest
*/
func (a *ShipmentAPIService) GetAllShipments(ctx context.Context) ApiGetAllShipmentsRequest {
	return ApiGetAllShipmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllShipments
func (a *ShipmentAPIService) GetAllShipmentsExecute(r ApiGetAllShipmentsRequest) (*GetAllShipments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllShipments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetAllShipments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCarrierAccountRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetCarrierAccountRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetCarrierAccountRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiGetCarrierAccountRequest) Execute() (*GetCarrierAccount200Response, *http.Response, error) {
	return r.ApiService.GetCarrierAccountExecute(r)
}

/*
GetCarrierAccount Get Carrier Accounts

This operation retrieves onboarded Carriers with their Carrier Account Ids which uniquely identify multiple accounts of same carrier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCarrierAccountRequest
*/
func (a *ShipmentAPIService) GetCarrierAccount(ctx context.Context) ApiGetCarrierAccountRequest {
	return ApiGetCarrierAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCarrierAccount200Response
func (a *ShipmentAPIService) GetCarrierAccountExecute(r ApiGetCarrierAccountRequest) (*GetCarrierAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCarrierAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetCarrierAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/carrierAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCarriersRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetCarriersRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetCarriersRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiGetCarriersRequest) Execute() (*Carriers, *http.Response, error) {
	return r.ApiService.GetCarriersExecute(r)
}

/*
GetCarriers Get Carriers

This operation fetches all supported carriers. This service is used to get list of supported carriers and their properties.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCarriersRequest
*/
func (a *ShipmentAPIService) GetCarriers(ctx context.Context) ApiGetCarriersRequest {
	return ApiGetCarriersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Carriers
func (a *ShipmentAPIService) GetCarriersExecute(r ApiGetCarriersRequest) (*Carriers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Carriers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/carriers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCountriesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
	carrier *string
	originCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetCountriesRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetCountriesRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This indicates the carrierID, a unique identifier given to  an individual carrier.
func (r ApiGetCountriesRequest) Carrier(carrier string) ApiGetCountriesRequest {
	r.carrier = &carrier
	return r
}

// This indicates the Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetCountriesRequest) OriginCountryCode(originCountryCode string) ApiGetCountriesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

func (r ApiGetCountriesRequest) Execute() ([]CountriesInner, *http.Response, error) {
	return r.ApiService.GetCountriesExecute(r)
}

/*
GetCountries Get Countries

This operation fetches list of supported destination countries for a provided carrier and origin country. If query parameters are not provided, it will default to `USPS` as carrier and `US` as origin country.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCountriesRequest
*/
func (a *ShipmentAPIService) GetCountries(ctx context.Context) ApiGetCountriesRequest {
	return ApiGetCountriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CountriesInner
func (a *ShipmentAPIService) GetCountriesExecute(r ApiGetCountriesRequest) ([]CountriesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CountriesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetCountries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetParcelTypesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
	carrier *string
	originCountryCode *string
	destinationCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetParcelTypesRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetParcelTypesRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This indicates the CarrierID, a unique identifier given to an individual carrier. It can be referred from the response of Get Carriers API
func (r ApiGetParcelTypesRequest) Carrier(carrier string) ApiGetParcelTypesRequest {
	r.carrier = &carrier
	return r
}

// This indicates the Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetParcelTypesRequest) OriginCountryCode(originCountryCode string) ApiGetParcelTypesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

// This indicates the Destination Country for the Shipment. The two-character ISO country code for the country where the shipment is to be delivered.
func (r ApiGetParcelTypesRequest) DestinationCountryCode(destinationCountryCode string) ApiGetParcelTypesRequest {
	r.destinationCountryCode = &destinationCountryCode
	return r
}

func (r ApiGetParcelTypesRequest) Execute() ([]ParcelTypesInner, *http.Response, error) {
	return r.ApiService.GetParcelTypesExecute(r)
}

/*
GetParcelTypes Get Parcel Types

This operation fetches Parcel Types based on the provided carrier, origin county, and the destination country. If query parameters are not provided, this will default to `USPS` as carrier, `US` as both origin and destination country code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetParcelTypesRequest
*/
func (a *ShipmentAPIService) GetParcelTypes(ctx context.Context) ApiGetParcelTypesRequest {
	return ApiGetParcelTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ParcelTypesInner
func (a *ShipmentAPIService) GetParcelTypesExecute(r ApiGetParcelTypesRequest) ([]ParcelTypesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ParcelTypesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetParcelTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/parcelTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	if r.destinationCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCountryCode", r.destinationCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	getRatesRequest *GetRatesRequest
	xPBDeveloperPartnerID *string
	compactResponse *bool
}

func (r ApiGetRatesRequest) GetRatesRequest(getRatesRequest GetRatesRequest) ApiGetRatesRequest {
	r.getRatesRequest = &getRatesRequest
	return r
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetRatesRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetRatesRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This header defines if the response required is detailed or compact. When value is set to true, it will only return rates object in response.
func (r ApiGetRatesRequest) CompactResponse(compactResponse bool) ApiGetRatesRequest {
	r.compactResponse = &compactResponse
	return r
}

func (r ApiGetRatesRequest) Execute() (*GetRates200Response, *http.Response, error) {
	return r.ApiService.GetRatesExecute(r)
}

/*
GetRates Rate Shop and Get Single Rate

This API contains 2 operations, rate shop and single rate. Rate shop will fetch rates for all carrier services based on the given addresses (From and To), weight, and dimension for given parcelType. If parcelType is not provided, it will default to `PKG`. Single rate will get rate for specific service and special service (if requested) based on the given addresses (From and To), weight, and dimension, parcelType and serviceId with or without specialServices. Single rate will be used mainly to a rate a shipment before creating shipment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRatesRequest
*/
func (a *ShipmentAPIService) GetRates(ctx context.Context) ApiGetRatesRequest {
	return ApiGetRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRates200Response
func (a *ShipmentAPIService) GetRatesExecute(r ApiGetRatesRequest) (*GetRates200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRates200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getRatesRequest == nil {
		return localVarReturnValue, nil, reportError("getRatesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	if r.compactResponse != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "compactResponse", r.compactResponse, "")
	}
	// body params
	localVarPostBody = r.getRatesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServicesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
	carrier *string
	originCountryCode *string
	destinationCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetServicesRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetServicesRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This indicates the CarrierID, a unique identifier provided to an individual carrier. It can be referred from the response of Get Carriers API
func (r ApiGetServicesRequest) Carrier(carrier string) ApiGetServicesRequest {
	r.carrier = &carrier
	return r
}

// This indicates the Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetServicesRequest) OriginCountryCode(originCountryCode string) ApiGetServicesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

// This indicates the Destination Country for the Shipment. The two-character ISO country code for the country where the shipment is to be delivered.
func (r ApiGetServicesRequest) DestinationCountryCode(destinationCountryCode string) ApiGetServicesRequest {
	r.destinationCountryCode = &destinationCountryCode
	return r
}

func (r ApiGetServicesRequest) Execute() ([]ServicesInner, *http.Response, error) {
	return r.ApiService.GetServicesExecute(r)
}

/*
GetServices Get Services

This operation fetches a list of supported services for a carrier with respect to specific origin and destination country. If query parameters are not provided, this will default to `USPS` as carrier, `US` as both origin and destination country code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServicesRequest
*/
func (a *ShipmentAPIService) GetServices(ctx context.Context) ApiGetServicesRequest {
	return ApiGetServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ServicesInner
func (a *ShipmentAPIService) GetServicesExecute(r ApiGetServicesRequest) ([]ServicesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServicesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	if r.destinationCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCountryCode", r.destinationCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignatureImageERRRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	xPBDeveloperPartnerID *string
}

// The Developer Partner ID is assigned by PB to uniquely identify a Developer&#39;s strategic business partners. If the developer is the sole business partner, this field is not required.
func (r ApiGetSignatureImageERRRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetSignatureImageERRRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiGetSignatureImageERRRequest) Execute() (*SignatureFileResponse, *http.Response, error) {
	return r.ApiService.GetSignatureImageERRExecute(r)
}

/*
GetSignatureImageERR Signature Image ERR

This operation provides a downloadable link which consists of a signature image for specific ERR (Electronic Return Receipt) shipment, and this is known as POD. <br /> Proof of Delivery (POD) is a document or file that shows an evidence of shipment delivery. This file contains the digital copy of recipient's signature, i.e., the signature image, in the form of downloadable link or URL.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId Shipment ID is a unique identifier for an individual shipment.
 @return ApiGetSignatureImageERRRequest
*/
func (a *ShipmentAPIService) GetSignatureImageERR(ctx context.Context, shipmentId string) ApiGetSignatureImageERRRequest {
	return ApiGetSignatureImageERRRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return SignatureFileResponse
func (a *ShipmentAPIService) GetSignatureImageERRExecute(r ApiGetSignatureImageERRRequest) (*SignatureFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetSignatureImageERR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/err/shipments/{shipmentId}/signaturefile"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpecialServicesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerID *string
	service *string
	parcel *string
	carrier *string
	originCountryCode *string
	destinationCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetSpecialServicesRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetSpecialServicesRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This indicates the serviceId. It can be referred from response of &#x60;Get Services&#x60; API
func (r ApiGetSpecialServicesRequest) Service(service string) ApiGetSpecialServicesRequest {
	r.service = &service
	return r
}

// This indicates the parcel Id, a unique identifier named to individual package. It can be referred from response of &#x60;Get Parcel Types&#x60; API
func (r ApiGetSpecialServicesRequest) Parcel(parcel string) ApiGetSpecialServicesRequest {
	r.parcel = &parcel
	return r
}

// This indicates the CarrierID, a unique identifier given to  an individual carrier. It can be referred from response of &#x60;Get Carriers&#x60; API
func (r ApiGetSpecialServicesRequest) Carrier(carrier string) ApiGetSpecialServicesRequest {
	r.carrier = &carrier
	return r
}

// This indicates the Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetSpecialServicesRequest) OriginCountryCode(originCountryCode string) ApiGetSpecialServicesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

// This indicates the Destination Country for the Shipment. The two-character ISO country code for the country where the shipment is to be delivered.
func (r ApiGetSpecialServicesRequest) DestinationCountryCode(destinationCountryCode string) ApiGetSpecialServicesRequest {
	r.destinationCountryCode = &destinationCountryCode
	return r
}

func (r ApiGetSpecialServicesRequest) Execute() (*SpecialServices, *http.Response, error) {
	return r.ApiService.GetSpecialServicesExecute(r)
}

/*
GetSpecialServices Get Special Services

This operation fetches Special Services for a given carrier, service, origin country, and the destination country. If query parameters are not provided, it will default to `USPS` as carrier,`US` as both origin and destination country and would show for all service and parcel types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpecialServicesRequest
*/
func (a *ShipmentAPIService) GetSpecialServices(ctx context.Context) ApiGetSpecialServicesRequest {
	return ApiGetSpecialServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpecialServices
func (a *ShipmentAPIService) GetSpecialServicesExecute(r ApiGetSpecialServicesRequest) (*SpecialServices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpecialServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetSpecialServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/specialServices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.service != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "")
	}
	if r.parcel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parcel", r.parcel, "")
	}
	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	if r.destinationCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCountryCode", r.destinationCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReprintShipmentByIdRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	xPBDeveloperPartnerID *string
	compactResponse *bool
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiReprintShipmentByIdRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiReprintShipmentByIdRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This header defines if the response required is detailed or compact. When value is set to true, it will only return label layout details and parcel tracking number object in response.
func (r ApiReprintShipmentByIdRequest) CompactResponse(compactResponse bool) ApiReprintShipmentByIdRequest {
	r.compactResponse = &compactResponse
	return r
}

func (r ApiReprintShipmentByIdRequest) Execute() (*ReprintShipment, *http.Response, error) {
	return r.ApiService.ReprintShipmentByIdExecute(r)
}

/*
ReprintShipmentById Reprint Shipment

This operation reprints Shipment by the shipmentId. It retrieves an existing shipping label to reprint. The API sends the shipmentId returned by the original Created Shipment request. Use this only if the shipping label in the Create Shipment response was spoilt or lost.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId This indicates the shipmentId, a unique identifier assigned to the Shipment.
 @return ApiReprintShipmentByIdRequest
*/
func (a *ShipmentAPIService) ReprintShipmentById(ctx context.Context, shipmentId string) ApiReprintShipmentByIdRequest {
	return ApiReprintShipmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return ReprintShipment
func (a *ShipmentAPIService) ReprintShipmentByIdExecute(r ApiReprintShipmentByIdRequest) (*ReprintShipment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReprintShipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.ReprintShipmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}/reprint"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	if r.compactResponse != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "compactResponse", r.compactResponse, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipmentByIdRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	xPBDeveloperPartnerID *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiShipmentByIdRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiShipmentByIdRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiShipmentByIdRequest) Execute() (*GetSingleShipment, *http.Response, error) {
	return r.ApiService.ShipmentByIdExecute(r)
}

/*
ShipmentById Get Shipment by Id

This operation retrieves shipment details using shipmentId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId This indicates the shipmentId, a unique identifier for an individual Shipment.
 @return ApiShipmentByIdRequest
*/
func (a *ShipmentAPIService) ShipmentById(ctx context.Context, shipmentId string) ApiShipmentByIdRequest {
	return ApiShipmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return GetSingleShipment
func (a *ShipmentAPIService) ShipmentByIdExecute(r ApiShipmentByIdRequest) (*GetSingleShipment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSingleShipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.ShipmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
